# -*- coding: utf-8 -*-
"""Stocks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pZf6Az8jxtkXI6-UDumjaYj063Pf1cBa
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

def load_stock_data(ticker, start="2020-01-01"):
    """
    Fetch historical stock data for a given ticker from Yahoo Finance.
    """
    df = yf.download(ticker, start=start)
    return df[['Close']]  # Keep only closing price


def preprocess_data(df, sequence_length=100):
    """
    Prepare stock price data for LSTM model training.

    Args:
        df (pd.DataFrame): Input DataFrame containing stock price data.
        sequence_length (int): Length of the sequence for LSTM.

    Returns:
        x (np.array): Input sequences for the LSTM model.
        y (np.array): Target values for the LSTM model.
        scaler (MinMaxScaler): Scaler object for inverse transformation.

    Raises:
        ValueError: If the input DataFrame is empty, contains no numeric columns,
                   or has insufficient rows for the specified sequence_length.
    """
    # Check if the DataFrame is empty
    if df.empty:
        raise ValueError("Input DataFrame is empty.")

    # Check if the DataFrame contains numeric columns
    if not any(df.dtypes.apply(lambda x: np.issubdtype(x, np.number))):
        raise ValueError("Input DataFrame must contain numeric columns.")

    # Check if the DataFrame has enough rows for the sequence_length
    if len(df) < sequence_length:
        raise ValueError(
            f"Input DataFrame must have at least {sequence_length} rows. "
            f"Current DataFrame has {len(df)} rows."
        )

    # Initialize the scaler
    scaler = MinMaxScaler(feature_range=(0, 1))

    # Scale the data
    df_scaled = scaler.fit_transform(df)

    # Prepare the training data
    x, y = [], []
    for i in range(sequence_length, len(df_scaled)):
        x.append(df_scaled[i-sequence_length:i])
        y.append(df_scaled[i, 0])  # Assuming the target is the first column

    # Convert lists to numpy arrays
    x = np.array(x)
    y = np.array(y)

    return x, y, scaler

from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout

def build_lstm_model(input_shape):
    """
    Create an LSTM model for stock price prediction.
    """
    model = Sequential()
    model.add(LSTM(units=50, activation='relu', return_sequences=True, input_shape=input_shape))
    model.add(Dropout(0.2))
    model.add(LSTM(units=60, activation='relu', return_sequences=True))
    model.add(Dropout(0.3))
    model.add(LSTM(units=80, activation='relu', return_sequences=True))
    model.add(Dropout(0.4))
    model.add(LSTM(units=120, activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(units=1))

    model.compile(optimizer='adam', loss='mean_squared_error')
    return model

def train_model(model, x_train, y_train, epochs=50, batch_size=32):
    """
    Train the LSTM model on stock data.
    """
    model.fit(x_train, y_train, epochs=epochs, batch_size=batch_size, verbose=1)
    return model

# Function to train the model with validation
def train_model(model, x_train, y_train, x_val, y_val, epochs=50, batch_size=32):
    """
    Train the LSTM model on stock data with validation.
    """
    history = model.fit(
        x_train, y_train,
        validation_data=(x_val, y_val),  # Use validation data
        epochs=epochs,
        batch_size=batch_size,
        verbose=1
    )

    # Print final training and validation loss
    final_train_loss = history.history['loss'][-1]
    final_val_loss = history.history['val_loss'][-1]

    print(f"\n✅ Final Training Loss: {final_train_loss:.4f}")
    print(f"✅ Final Validation Loss: {final_val_loss:.4f}")

    return model, history

def predict_stock(model, scaler, df, sequence_length=100):
    """
    Predict stock prices using the trained LSTM model.
    """
    df_scaled = scaler.transform(df)
    x_test = []

    for i in range(sequence_length, len(df_scaled)):
        x_test.append(df_scaled[i-sequence_length:i])

    x_test = np.array(x_test)
    predictions = model.predict(x_test)
    return scaler.inverse_transform(predictions)  # Convert back to original price scale

# Function to plot actual vs predicted stock prices
def plot_predictions(actual, predicted):
    """
    Plot actual vs. predicted stock prices.
    """
    plt.figure(figsize=(12,6))
    plt.plot(actual, label="Actual Prices", color='blue')
    plt.plot(predicted, label="Predicted Prices", color='red', linestyle='dashed')
    plt.xlabel("Time")
    plt.ylabel("Stock Price")
    plt.title("Stock Price Prediction")
    plt.legend()
    plt.show()

# Function to plot training vs validation loss
def plot_training_history(history):
    """
    Plot training loss and validation loss over epochs.
    """
    plt.figure(figsize=(10,5))
    plt.plot(history.history['loss'], label='Training Loss', color='blue')
    plt.plot(history.history['val_loss'], label='Validation Loss', color='red')
    plt.xlabel("Epochs")
    plt.ylabel("Loss")
    plt.title("Training vs. Validation Loss")
    plt.legend()
    plt.show()

# MAIN EXECUTION FLOW
if __name__ == "__main__":
    # Load data
    ticker = "AAPL"  # Change this to any stock symbol
    df = load_stock_data(ticker)

    # Split data into training and validation sets
    split_ratio = 0.8
    train_size = int(len(df) * split_ratio)

    df_train = df[:train_size]
    df_val = df[train_size:]

    # Preprocess data
    x_train, y_train, scaler = preprocess_data(df_train)
    x_val, y_val, _ = preprocess_data(df_val)

    # Build & Train Model
    model = build_lstm_model(input_shape=(x_train.shape[1], 1))
    trained_model, history = train_model(model, x_train, y_train, x_val, y_val)

    # Plot Training History
    plot_training_history(history)

    # Make Predictions
    predictions = predict_stock(trained_model, scaler, df_val)

    # Plot Results
    plot_predictions(df_val['Close'].values, predictions)